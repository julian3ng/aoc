(defpackage :intcode
  (:use :common-lisp)
  (:import-from :uiop/utility
                :split-string)
  (:export :eval-program-string))

(in-package :intcode)

(defun digits (num)
  (loop with result = '()
     while (> num 0) do
       (multiple-value-bind (divisor remainder) (floor num 10)
         (push remainder result)
         (setf num divisor))
     finally (return result)))

(defun get-parameter-modes (opcode)
  (let ((ds (digits opcode)))
    (do ((ds ds (cons 0 ds)))
        ((= (length ds) 5)
         (append (subseq ds 0 3) (list (+  (* 10 (elt ds 3))
                                           (elt ds 4))))))))
(defun eval-at-iptr (storage iptr
                     &key (debug 0) (stream *query-io*) (out-stream *standard-output*)
                       (out-format "~A"))
  (destructuring-bind (mode3 mode2 mode1 op) (get-parameter-modes (aref storage iptr))
    (when (> debug 0)
      (format t "iptr: ~A, op: ~A, modes: [~A ~A ~A]~%" iptr op mode1 mode2 mode3))
    (if (/= op 99)
        (let ()
          (labels ((imm1 () (aref storage (+ iptr 1)))
                   (imm2 () (aref storage (+ iptr 2)))
                   (imm3 () (aref storage (+ iptr 3)))
                   (v1 () (if (= mode1 1) (imm1) (aref storage (imm1))))
                   (v2 () (if (= mode2 1) (imm2) (aref storage (imm2))))
                   (v3 () (if (= mode3 1) (imm3) (aref storage (imm3)))))
            (cond
              ((= op 1) (progn  (when (> debug 0)
                                  (format t "+: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                                (setf (aref storage (imm3)) (+ (v1) (v2)))
                                (+ iptr 4)))
              ((= op 2) (progn  (when (> debug 0)
                                  (format t "*: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                                (setf (aref storage (imm3)) (* (v1) (v2)))
                                (+ iptr 4)))
              ((= op 3) (progn (setf (aref storage (imm1)) (progn (when (> debug 0) (format t "intcode>"))
                                                                  (read stream)))
                               (+ iptr 2)))
              ((= op 4) (progn (format out-stream out-format (v1))
                               (+ iptr 2)))
              ((= op 5) (progn (when (> debug 0)
                                 (format t "jit: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                               (if (not (zerop (v1)))
                                   (v2)
                                   (+ iptr 3))) )
              ((= op 6) (progn (when (> debug 0)
                                 (format t "jint: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                               (if (zerop (v1))
                                   (v2)
                                   (+ iptr 3))))
              ((= op 7) (progn (when (> debug 0)
                                 (format t "<: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                               (setf (aref storage (imm3)) (if (< (v1) (v2)) 1 0))
                               (+ iptr 4)))
              ((= op 8) (progn (when (> debug 0)
                                 (format t "=: ~A[=~A] ~A[=~A]~%" (imm1) (v1) (imm2) (v2)))
                               (setf (aref storage (imm3)) (if (= (v1) (v2)) 1 0))
                               (+ iptr 4)))              
              (t (progn (format t "Invalid opcode: ~A~%" op) nil)))))
        (when (> debug 1)
          (format t "~A" storage)))))

(defun eval-program (storage
                     &key (debug 0) (stream *query-io*) (out-stream *standard-output*)
                       (out-format "~A"))
  (do ((iptr 0 (eval-at-iptr storage iptr :debug debug :stream stream :out-stream out-stream
                             :out-format out-format)))
      ((null iptr))))

(defun eval-program-string (str
                            &key (debug 0) (stream *query-io*) (out-stream *standard-output*)
                              (out-format "~A"))
  (let* ((code (mapcar #'parse-integer (split-string str :separator '(#\,))))
         (storage (make-array (length code) :initial-contents code)))
    (eval-program storage :debug debug :stream stream :out-stream out-stream :out-format out-format)))

(defun tests ()
  (eval-program-string "1,0,0,0,99" :debug 10)
  (eval-program-string "1101,0,0,0,99" :debug 10)
  (eval-program-string "1102,3,2,3,99" :debug 10)
  (eval-program-string "1002,2,2,3,99" :debug 10)
  (eval-program-string "3,1,2,1,1,0,4,0,99")
  (eval-program-string "3,1,1005,1,8,104,11111,99,104,22222,99")
  (eval-program-string "3,1,1006,1,8,104,11111,99,104,22222,99")
  (eval-program-string "3,1,1007,1,0,1,04,1,99")
  (eval-program-string "3,1,1008,1,0,1,04,1,99"))
